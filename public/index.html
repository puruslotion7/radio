<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>F√∏roysk √∫tv√∏rp</title>

  <link rel="preconnect" href="https://stream-secure.midlar.fo" crossorigin>
  <link rel="preconnect" href="https://play.kringvarp.fo" crossorigin>
  <link rel="preconnect" href="https://w-live-edge1.kringvarp.fo" crossorigin>
  <link rel="preconnect" href="https://high.lindin.fo" crossorigin>

  <style>
    /* Theme tokens */
    :root{
      --bg: #0b0f17;
      --fg: #ffffff;
      --muted: rgba(255,255,255,0.8);
      --card: rgba(255,255,255,0.06);
      --cardHover: rgba(255,255,255,0.12);
      --border: rgba(255,255,255,0.12);
      --border2: rgba(255,255,255,0.10);
      --chip: rgba(0,0,0,0.20);
      --chip2: rgba(0,0,0,0.25);
      --statusBg: rgba(255,255,255,0.08);
      --accent: #2b6cff;

      --dockBg: rgba(15, 20, 35, 0.92);
      --dockBorder: rgba(255,255,255,0.14);
      --shadow: 0 12px 35px rgba(0,0,0,0.45);

      --audioEnclosureBg: transparent;
      --audioPanelBg: transparent;
      --audioText: #ffffff;
    }

    html[data-theme="light"]{
      --bg: #f6f7fb;
      --fg: #0b0f17;
      --muted: rgba(0,0,0,0.75);
      --card: rgba(0,0,0,0.04);
      --cardHover: rgba(0,0,0,0.07);
      --border: rgba(0,0,0,0.10);
      --border2: rgba(0,0,0,0.10);
      --chip: rgba(255,255,255,0.75);
      --chip2: rgba(255,255,255,0.85);
      --statusBg: rgba(0,0,0,0.05);

      --dockBg: rgba(255,255,255,0.92);
      --dockBorder: rgba(0,0,0,0.10);
      --shadow: 0 12px 35px rgba(0,0,0,0.15);

      --audioEnclosureBg: rgba(255,255,255,0.88);
      --audioPanelBg: rgba(255,255,255,0.88);
      --audioText: #0b0f17;
    }

    * { box-sizing: border-box; }
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    body { margin:0; background:var(--bg); color:var(--fg); overflow-x: hidden; }
    .wrap { max-width:900px; margin:auto; padding:24px; width: 100%; }

    h1 { margin: 0; }
    .header {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      margin-bottom: 16px;
    }

    /* Toggle switch */
    .theme-toggle {
      display:flex;
      align-items:center;
      gap:10px;
      user-select:none;
      font-size: 13px;
      color: var(--muted);
    }
    .switch {
      position: relative;
      width: 48px;
      height: 28px;
      border-radius: 999px;
      background: var(--card);
      border: 1px solid var(--border);
      cursor: pointer;
      flex: 0 0 auto;
    }
    .knob {
      position:absolute;
      top: 3px;
      left: 3px;
      width: 22px;
      height: 22px;
      border-radius: 999px;
      background: var(--fg);
      opacity: 0.9;
      transition: transform 180ms ease;
    }
    .switch[data-on="true"] .knob { transform: translateX(20px); }
    .switch-icon {
      width: 16px;
      height: 16px;
      display:grid;
      place-items:center;
      opacity: 0.85;
    }

    /* Stations grid */
    .stations {
      display:grid;
      grid-template-columns: repeat(auto-fit,minmax(180px,1fr));
      gap:14px;
      grid-auto-rows: 1fr;
    }

    .station {
      padding:18px;
      border-radius:16px;
      background:var(--card);
      border:1px solid var(--border);
      cursor:pointer;
      transition:0.15s ease;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:10px;
      text-align:center;
      position: relative;
      user-select: none;
    }
    .station:hover { background:var(--cardHover); transform:translateY(-2px); }
    .station.active { border:2px solid var(--accent); background: color-mix(in srgb, var(--accent) 14%, var(--card)); }

    .station .logoText {
      width: 100%;
      height: 44px;
      display: grid;
      place-items: center;
      border-radius: 12px;
      background: var(--chip);
      border: 1px solid var(--border2);
      font-weight: 800;
      letter-spacing: 0.6px;
      font-size: 18px;
      position: relative;
    }
    .station .subText {
      font-size: 12px;
      opacity: 0.85;
      color: var(--muted);
      margin-top: -6px;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .station .icon {
      width: 40px;
      height: 40px;
      border-radius: 999px;
      display: grid;
      place-items: center;
      background: var(--chip2);
      border: 1px solid var(--border2);
    }
    .station .icon svg { width: 22px; height: 22px; opacity: 0.95; }

    .spinner {
      width: 18px;
      height: 18px;
      border: 2px solid color-mix(in srgb, var(--fg) 25%, transparent);
      border-top: 2px solid var(--fg);
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .station.error {
      border-color: #ff4444;
      background: color-mix(in srgb, #ff4444 10%, var(--card));
    }
    .station.retrying .logoText::after {
      content: '';
      position: absolute;
      top: 4px;
      right: 4px;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ffaa00;
      animation: pulse 1s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 0.4; transform: scale(0.9); }
      50% { opacity: 1; transform: scale(1.1); }
    }

    .status {
      margin-top:15px;
      padding:10px 12px;
      border-radius:12px;
      background:var(--statusBg);
      font-size:14px;
      color: var(--muted);
    }

    .visitor-count {
      margin-top:10px;
      padding:8px 12px;
      border-radius:12px;
      background:var(--statusBg);
      font-size:13px;
      color: var(--muted);
      text-align: center;
      opacity: 0.8;
    }
    .visitor-count #visitorNumber {
      font-weight: 600;
      color: var(--fg);
    }

    /* Equalizer */
    .eq {
      display: inline-flex;
      align-items: flex-end;
      gap: 2px;
      height: 16px;
      margin-top: 2px;
      opacity: 0.75;
    }
    .eq span {
      width: 2px;
      height: 16px;
      border-radius: 1px;
      background: currentColor;
      transform-origin: bottom;
      opacity: 0.8;
      transition: transform 0.08s ease-out;
    }

    /* Dock wrapper */
    .player-dock { margin-top: 24px; }

    /* Audio element */
    .styled-audio {
      width: 100%;
      display: block;
      border-radius: 16px;
      background: var(--card);
      padding: 8px;
      box-sizing: border-box;
    }

    /* ===== WebKit native controls: style BOTH layers ===== */
    .styled-audio::-webkit-media-controls-enclosure {
      background-color: var(--audioEnclosureBg) !important;
      border-radius: 12px;
    }
    .styled-audio::-webkit-media-controls-panel {
      background-color: var(--audioPanelBg) !important;
      border-radius: 12px;
    }

    .styled-audio::-webkit-media-controls-current-time-display,
    .styled-audio::-webkit-media-controls-time-remaining-display {
      color: var(--audioText) !important;
    }

    /* Dark mode: keep timeline visible against dark dock/card */
    html:not([data-theme="light"])
    .styled-audio::-webkit-media-controls-timeline {
      filter: invert(1);
    }

    /* ‚úÖ Dark mode: make icon buttons white (play/pause + volume etc.) */
    html:not([data-theme="light"])
    .styled-audio::-webkit-media-controls-play-button,
    html:not([data-theme="light"])
    .styled-audio::-webkit-media-controls-mute-button,
    html:not([data-theme="light"])
    .styled-audio::-webkit-media-controls-volume-slider-container,
    html:not([data-theme="light"])
    .styled-audio::-webkit-media-controls-fullscreen-button,
    html:not([data-theme="light"])
    .styled-audio::-webkit-media-controls-seek-back-button,
    html:not([data-theme="light"])
    .styled-audio::-webkit-media-controls-seek-forward-button {
      filter: invert(1);
    }

    /* Mobile optimization + docked player */
    @media (max-width: 600px) {
      .wrap { padding: 16px; padding-bottom: 140px; }

      .stations { grid-template-columns: repeat(2, 1fr); gap: 10px; }
      .station { padding: 12px; gap: 6px; }
      .station .logoText { height: 36px; font-size: 15px; }
      .station .subText { font-size: 11px; }
      .station .icon { width: 32px; height: 32px; }
      .station .icon svg { width: 18px; height: 18px; }
      .eq { height: 10px; }
      .eq span { width: 2px; height: 5px; }

      .player-dock {
        position: fixed;
        left: 12px;
        right: 12px;
        bottom: calc(12px + env(safe-area-inset-bottom));
        z-index: 999;

        padding: 10px;
        border-radius: 18px;
        background: var(--dockBg);
        border: 1px solid var(--dockBorder);
        box-shadow: var(--shadow);
        backdrop-filter: blur(10px);
        box-sizing: border-box;
        max-width: calc(100vw - 24px);
      }

      .player-dock .styled-audio {
        padding: 0;
        background: transparent;
      }
    }
  </style>
</head>

<body>
<div class="wrap">
  <div class="header">
    <h1>F√∏roysk √∫tv√∏rp</h1>

    <div class="theme-toggle" aria-label="Theme toggle">
      <span class="switch-icon" aria-hidden="true">‚òæ</span>
      <div id="themeSwitch" class="switch" role="switch" aria-checked="false" tabindex="0" data-on="false">
        <div class="knob"></div>
      </div>
      <span class="switch-icon" aria-hidden="true">‚òÄÔ∏é</span>
    </div>
  </div>

  <div class="stations" id="stations"></div>

  <div class="player-dock">
    <audio id="audio" class="styled-audio" controls preload="auto" playsinline></audio>
  </div>

  <div class="status" id="status">Status: idle</div>

  <div class="visitor-count" id="visitorCount">
    <span id="visitorNumber">-</span> online
  </div>
</div>

<!-- HLS.js for Chrome/Firefox/Edge -->
<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

<script>
  const STATIONS = [
    {
      name: "KVF",
      type: "hls",
      stream: "https://w-live-edge1.kringvarp.fo/radio/_definst_/smil:radio.smil/playlist.m3u8",
      subtitle: ""
    },
    {
      name: "KVF2",
      type: "hls",
      stream: "https://w-live-edge1.kringvarp.fo/radio2/_definst_/smil:radio2.smil/playlist.m3u8",
      subtitle: ""
    },
    {
      name: "Tingvarp",
      type: "hls",
      stream: "https://w-live-edge1.kringvarp.fo/tingradio/_definst_/smil:tingradio.smil/playlist.m3u8",
      subtitle: ""
    },
    {
      name: "FM1",
      type: "direct",
      stream: "https://stream-secure.midlar.fo/fm1-128",
      subtitle: ""
    },
    {
      name: "Voxpop",
      type: "direct",
      stream: "https://stream-secure.midlar.fo/voxpop-128",
      subtitle: ""
    },
    {
      name: "Lindin",
      type: "direct",
      stream: "https://high.lindin.fo/",
      subtitle: ""
    },
    {
      name: "FM98,7",
      type: "direct",
      stream: "https://liveradio.stream.fo/listen/fm98,7/web",
      subtitle: ""
    },
    {
      name: "Aldan",
      type: "direct",
      stream: "https://streaming.radio.co/s4d14b9fcc/listen",
      subtitle: ""
    },
  ].sort((a, b) => a.name.localeCompare(b.name));

  const audio = document.getElementById("audio");
  const stationsContainer = document.getElementById("stations");
  const status = document.getElementById("status");

  /* ===== Web Audio API setup for gain control, compression, and analyser ===== */
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();

  // Set a baseline gain that works well across all stations
  const gainNode = audioContext.createGain();
  gainNode.gain.value = 1.5; // Reasonable baseline - boost quieter stations

  // Dynamic compressor for volume normalization
  const compressor = audioContext.createDynamicsCompressor();
  compressor.threshold.setValueAtTime(-24, audioContext.currentTime); // Start compressing at -24dB
  compressor.knee.setValueAtTime(30, audioContext.currentTime); // Smooth compression curve
  compressor.ratio.setValueAtTime(12, audioContext.currentTime); // 12:1 compression ratio
  compressor.attack.setValueAtTime(0.003, audioContext.currentTime); // Fast attack (3ms)
  compressor.release.setValueAtTime(0.25, audioContext.currentTime); // 250ms release

  const analyserNode = audioContext.createAnalyser();
  analyserNode.fftSize = 128;
  analyserNode.smoothingTimeConstant = 0.7;

  const frequencyData = new Uint8Array(analyserNode.frequencyBinCount);
  let audioSource = null;
  let animationFrameId = null;

  function connectAudioWithGain() {
    if (!audioSource) {
      audioSource = audioContext.createMediaElementSource(audio);
      // Chain: source -> gain -> compressor -> analyser -> output
      audioSource.connect(gainNode);
      gainNode.connect(compressor);
      compressor.connect(analyserNode);
      analyserNode.connect(audioContext.destination);
    }
  }

  /* ===== Real-time equalizer visualization ===== */
  function updateEqualizer() {
    if (!audio.paused && (audio.src || audio.currentSrc) && currentIndex !== null) {
      analyserNode.getByteFrequencyData(frequencyData);

      const stationCard = document.querySelectorAll(".station")[currentIndex];
      if (stationCard) {
        const bars = stationCard.querySelectorAll(".eq span");

        // Map 10 frequency bands across the spectrum
        for (let i = 0; i < 10; i++) {
          const start = i * 5;
          const end = start + 5;
          const slice = frequencyData.slice(start, end);
          const avg = slice.reduce((a, b) => a + b, 0) / slice.length;

          // Scale values to reasonable bar heights (0.2 to 1.4)
          const scale = 0.2 + (avg / 255) * 1.2;
          bars[i].style.transform = `scaleY(${scale})`;
        }
      }
    }

    animationFrameId = requestAnimationFrame(updateEqualizer);
  }

  function startEqualizer() {
    if (!animationFrameId) {
      updateEqualizer();
    }
  }

  function stopEqualizer() {
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }

    // Reset all bars
    document.querySelectorAll(".eq span").forEach(bar => {
      bar.style.transform = 'scaleY(0.2)';
    });
  }

  /* Theme toggle */
  const themeSwitch = document.getElementById("themeSwitch");
  const THEME_KEY = "radioTheme";

  function applyTheme(theme) {
    document.documentElement.setAttribute("data-theme", theme);
    const isLight = theme === "light";
    themeSwitch.dataset.on = String(isLight);
    themeSwitch.setAttribute("aria-checked", String(isLight));
  }
  function toggleTheme() {
    const current = document.documentElement.getAttribute("data-theme") || "dark";
    const next = current === "light" ? "dark" : "light";
    localStorage.setItem(THEME_KEY, next);
    applyTheme(next);
  }
  themeSwitch.addEventListener("click", toggleTheme);
  themeSwitch.addEventListener("keydown", (e) => {
    if (e.key === "Enter" || e.key === " ") { e.preventDefault(); toggleTheme(); }
  });
  (function initTheme(){
    const saved = localStorage.getItem(THEME_KEY);
    if (saved === "light" || saved === "dark") return applyTheme(saved);
    const prefersLight = window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches;
    applyTheme(prefersLight ? "light" : "dark");
  })();

  audio.crossOrigin = "anonymous";

  let currentIndex = null;
  let bufferingTimer = null;
  const BUFFERING_MESSAGE_DELAY_MS = 500;
  let metadataPollers = {};
  let errorRetryCount = 0;
  const MAX_RETRY_ATTEMPTS = 3;
  const RETRY_DELAY_MS = 3000;

  /* ===== HLS integration ===== */
  let hls = null;

  function isM3U8(url) {
    try {
      const u = new URL(url);
      return u.pathname.endsWith(".m3u8") || u.searchParams.get("type") === "m3u8";
    } catch {
      return String(url).includes(".m3u8") || String(url).includes("type=m3u8");
    }
  }

  function destroyHls() {
    if (hls) { try { hls.destroy(); } catch {} hls = null; }
  }

  function attachStreamToAudio(station) {
    destroyHls();
    const url = station.stream;

    const wantsHls = station.type === "hls" || isM3U8(url);
    const canNativeHls =
            audio.canPlayType("application/vnd.apple.mpegurl") === 'probably' ||
            audio.canPlayType("application/x-mpegURL") === 'probably';

    console.log('üîß attachStreamToAudio:', {
      station: station.name,
      url: url,
      wantsHls: wantsHls,
      canNativeHls: canNativeHls,
      hlsSupported: window.Hls && window.Hls.isSupported()
    });

    if (wantsHls && !canNativeHls && window.Hls && window.Hls.isSupported()) {
      console.log('üì¶ Using hls.js for', station.name);
      hls = new Hls({
        lowLatencyMode: false,
        backBufferLength: 10,
        maxBufferLength: 300,
        maxMaxBufferLength: 300,
        liveSyncDurationCount: 3,
        liveMaxLatencyDurationCount: 10,
        enableWorker: true,
        debug: false
      });

      // Comprehensive HLS event logging
      hls.on(Hls.Events.MANIFEST_PARSED, function() {
        console.log('‚úÖ HLS: Manifest parsed successfully');
      });

      hls.on(Hls.Events.LEVEL_LOADED, function(event, data) {
        console.log('‚úÖ HLS: Level loaded', data.details);
      });

      hls.on(Hls.Events.FRAG_LOADING, function(event, data) {
        console.log('‚è≥ HLS: Loading fragment', data.frag.url);
      });

      hls.on(Hls.Events.FRAG_LOADED, function(event, data) {
        console.log('‚úÖ HLS: Fragment loaded', data.frag.url);
      });

      hls.on(Hls.Events.ERROR, function (event, data) {
        console.error('‚ùå HLS Error:', {
          type: data.type,
          details: data.details,
          fatal: data.fatal,
          url: data.url,
          response: data.response,
          networkDetails: data.networkDetails
        });

        if (data.fatal) {
          switch(data.type) {
            case Hls.ErrorTypes.NETWORK_ERROR:
              console.error('üí• Fatal network error - attempting recovery');
              hls.startLoad();
              break;
            case Hls.ErrorTypes.MEDIA_ERROR:
              console.error('üí• Fatal media error - attempting recovery');
              hls.recoverMediaError();
              break;
            default:
              console.error('üí• Unrecoverable error - destroying HLS');
              break;
          }
        }
      });

      hls.loadSource(url);
      hls.attachMedia(audio);
      return;
    }

    console.log('üéµ Using native audio playback for', station.name);
    audio.src = url;
  }

  /* ===== Metadata polling and SSE ===== */
  let sseConnections = {};

  function startAllMetadataPolling() {
    STATIONS.forEach((station, index) => {
      // If station has SSE endpoint, use that instead of polling
      if (station.sseEndpoint) {
        startSSE(station, index);
      } else if (station.metadataCallback) {
        startPolling(station, index);
      }
    });
  }

  function startSSE(station, index) {
    try {
      const eventSource = new EventSource(station.sseEndpoint);

      eventSource.onmessage = function(event) {
        try {
          const data = JSON.parse(event.data);
          const metadata = data.radiotext || data.title || data.artist || null;
          console.log(`SSE data for ${station.name}:`, metadata);
          updateNowPlaying(index, metadata);
        } catch (err) {
          console.error(`SSE parse error for ${station.name}:`, err);
        }
      };

      eventSource.onerror = function(err) {
        console.error(`SSE error for ${station.name}, falling back to polling`, err);
        eventSource.close();
        // Fallback to polling if SSE fails
        if (station.metadataCallback) {
          startPolling(station, index);
        }
      };

      sseConnections[index] = eventSource;
    } catch (err) {
      console.error(`SSE setup failed for ${station.name}:`, err);
      // Fallback to polling
      if (station.metadataCallback) {
        startPolling(station, index);
      }
    }
  }

  function startPolling(station, index) {
    async function poll() {
      try {
        const metadata = await station.metadataCallback();
        // Only log when metadata is found
        if (metadata) {
          console.log(`‚úì ${station.name}:`, metadata);
        }
        updateNowPlaying(index, metadata);
      } catch (err) {
        console.error(`Metadata fetch failed for ${station.name}:`, err);
      }
    }

    // Poll immediately
    poll();

    // Then poll every 10 seconds
    metadataPollers[index] = setInterval(poll, 10000);
  }

  function updateNowPlaying(index, text) {
    const stationCard = document.querySelectorAll(".station")[index];
    if (!stationCard) return;

    const subTextEl = stationCard.querySelector(".subText");
    if (!subTextEl) return;

    if (text) {
      // Show now playing
      subTextEl.textContent = `‚ô´ ${text}`;
      subTextEl.title = text;
      subTextEl.style.fontStyle = "italic";
    } else {
      // Show subtitle
      const subtitle = subTextEl.getAttribute("data-subtitle") || "";
      subTextEl.textContent = subtitle;
      subTextEl.title = "";
      subTextEl.style.fontStyle = "normal";
    }
  }

  /* ===== UI ===== */
  function setStatus(msg){ status.textContent = "Status: " + msg; }

  function playIcon() {
    return `<svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
    <path d="M8 5v14l11-7z"></path>
  </svg>`;
  }
  function pauseIcon() {
    return `<svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
    <path d="M6 5h4v14H6zm8 0h4v14h-4z"></path>
  </svg>`;
  }
  function spinnerIcon() { return `<div class="spinner" aria-hidden="true"></div>`; }

  function renderStations(){
    STATIONS.forEach((station, index) => {
      const div = document.createElement("div");
      div.className = "station";
      div.setAttribute("role", "button");
      div.setAttribute("tabindex", "0");
      div.setAttribute("aria-label", `Toggle ${station.name}`);

      div.innerHTML = `
      <div class="logoText">${station.name}</div>
      <div class="eq" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></div>
      <div class="subText" data-subtitle="${station.subtitle || ""}">${station.subtitle || ""}</div>
      <div class="icon" aria-hidden="true">${playIcon()}</div>
    `;

      div.addEventListener("click", () => toggleStation(index));
      div.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") { e.preventDefault(); toggleStation(index); }
      });

      stationsContainer.appendChild(div);
    });
  }

  function updateUI(state = null) {
    document.querySelectorAll(".station").forEach((el, idx) => {
      const iconContainer = el.querySelector(".icon");
      const isCurrent = (idx === currentIndex);
      const isPlaying = isCurrent && !audio.paused && (audio.src || audio.currentSrc);

      el.classList.toggle("active", isCurrent);
      el.classList.toggle("playing", isPlaying);

      // Remove error/retry states when not current or when playing successfully
      if (!isCurrent || isPlaying) {
        el.classList.remove("error", "retrying");
      }

      if (!isCurrent) { iconContainer.innerHTML = playIcon(); return; }
      if (state === "loading") { iconContainer.innerHTML = spinnerIcon(); return; }
      if (state === "error") {
        el.classList.add("error");
        iconContainer.innerHTML = playIcon();
        return;
      }
      if (state === "retrying") {
        el.classList.add("retrying");
        el.classList.remove("error");
        iconContainer.innerHTML = spinnerIcon();
        return;
      }

      iconContainer.innerHTML = isPlaying ? pauseIcon() : playIcon();
    });
  }

  function scheduleBufferingStatus() {
    clearTimeout(bufferingTimer);
    bufferingTimer = setTimeout(() => {
      const name = currentIndex != null ? STATIONS[currentIndex].name : "stream";
      setStatus("Buffering‚Ä¶ (" + name + ")");
    }, BUFFERING_MESSAGE_DELAY_MS);
  }
  function cancelBufferingStatus() { clearTimeout(bufferingTimer); bufferingTimer = null; }

  async function toggleStation(index){
    const station = STATIONS[index];

    // Toggle play/pause if same station clicked
    if (currentIndex === index && (audio.src || audio.currentSrc)) {
      if (audio.paused) {
        try {
          updateUI("loading");
          scheduleBufferingStatus();
          await audio.play();
          cancelBufferingStatus();
          setStatus(`Playing ${station.name}`);
        } catch (e) {
          cancelBufferingStatus();
          setStatus("Error: " + (e?.message || e));
        }
      } else {
        audio.pause();
        setStatus(`Paused ${station.name}`);
      }
      updateUI();
      return;
    }

    // Switching to different station - stop equalizer and reset bars
    stopEqualizer();
    currentIndex = index;

    try { audio.pause(); } catch {}
    destroyHls();
    audio.removeAttribute("src");
    audio.load();

    attachStreamToAudio(station);
    audio.load();

    // Connect Web Audio API on first play (requires user interaction)
    connectAudioWithGain();

    // Resume audio context if suspended (Safari requirement)
    if (audioContext.state === 'suspended') {
      await audioContext.resume();
    }

    try {
      updateUI("loading");
      scheduleBufferingStatus();
      await audio.play();
      cancelBufferingStatus();
      setStatus(`Playing ${station.name}`);
    } catch(e){
      cancelBufferingStatus();
      setStatus("Error: " + (e?.message || e));
    }

    updateUI();
  }

  audio.addEventListener("waiting", () => { updateUI("loading"); scheduleBufferingStatus(); });
  audio.addEventListener("playing", () => {
    cancelBufferingStatus();
    errorRetryCount = 0; // Reset error count on successful playback
    if (currentIndex != null) {
      setStatus("Playing " + STATIONS[currentIndex].name);
    }
    updateUI();
    startEqualizer();
  });
  audio.addEventListener("pause", () => {
    cancelBufferingStatus();
    if (currentIndex != null && (audio.src || audio.currentSrc)) setStatus("Paused " + STATIONS[currentIndex].name);
    updateUI();
    stopEqualizer();
  });
  audio.addEventListener("ended", () => {
    cancelBufferingStatus();
    stopEqualizer();

    // Unexpected end for a live stream - try to reconnect
    if (currentIndex !== null && (audio.src || audio.currentSrc)) {
      console.log('‚ö†Ô∏è Stream ended unexpectedly, attempting reconnect...');
      const station = STATIONS[currentIndex];

      if (errorRetryCount < MAX_RETRY_ATTEMPTS) {
        errorRetryCount++;
        updateUI("retrying");
        setStatus(`Stream interrupted. Reconnecting (${errorRetryCount}/${MAX_RETRY_ATTEMPTS})...`);

        setTimeout(async () => {
          if (currentIndex !== null) {
            try {
              destroyHls();
              audio.removeAttribute("src");
              audio.load();

              attachStreamToAudio(station);
              audio.load();

              updateUI("loading");
              await audio.play();
              errorRetryCount = 0;
              setStatus(`Playing ${station.name}`);
              updateUI();
            } catch (e) {
              console.error('‚ùå Reconnect failed:', e);
              if (errorRetryCount >= MAX_RETRY_ATTEMPTS) {
                updateUI("error");
                setStatus(`Failed to reconnect to ${station.name}. Click to retry.`);
              }
            }
          }
        }, RETRY_DELAY_MS);
      } else {
        updateUI("error");
        setStatus("Stream disconnected. Click station to retry.");
        errorRetryCount = 0;
      }
    } else {
      // Normal stop
      setStatus("Stopped");
      currentIndex = null;
      updateUI();
    }
  });
  audio.addEventListener("error", () => {
    cancelBufferingStatus();
    stopEqualizer();

    if (currentIndex !== null && errorRetryCount < MAX_RETRY_ATTEMPTS) {
      errorRetryCount++;
      updateUI("retrying");
      setStatus(`Connection lost. Retrying (${errorRetryCount}/${MAX_RETRY_ATTEMPTS})...`);

      // Retry after delay
      setTimeout(async () => {
        if (currentIndex !== null) {
          const station = STATIONS[currentIndex];
          try {
            console.log(`üîÑ Retry attempt ${errorRetryCount} for ${station.name}`);
            destroyHls();
            audio.removeAttribute("src");
            audio.load();

            attachStreamToAudio(station);
            audio.load();

            updateUI("loading");
            await audio.play();
            errorRetryCount = 0; // Reset on success
            setStatus(`Playing ${station.name}`);
            updateUI();
          } catch (e) {
            console.error(`‚ùå Retry ${errorRetryCount} failed:`, e);
            if (errorRetryCount >= MAX_RETRY_ATTEMPTS) {
              updateUI("error");
              setStatus(`Failed to connect to ${station.name}. Click to retry.`);
            } else {
              setStatus(`Retry ${errorRetryCount} failed. Trying again...`);
            }
          }
        }
      }, RETRY_DELAY_MS);
    } else {
      errorRetryCount = 0;
      updateUI("error");
      setStatus("Connection failed. Click station to retry.");
    }
  });

  // Init
  renderStations();
  updateUI();
  startAllMetadataPolling();

  /* ===== Visitor tracking with WebSocket ===== */
  const visitorNumberEl = document.getElementById('visitorNumber');

  // Create WebSocket connection
  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  const wsUrl = `${protocol}//${window.location.host}`;

  const ws = new WebSocket(wsUrl);

  ws.onmessage = function(event) {
    try {
      const data = JSON.parse(event.data);
      if (visitorNumberEl) {
        visitorNumberEl.textContent = data.count;
      }
    } catch (err) {
      // Silent error handling
    }
  };

  ws.onclose = function() {
    // Attempt to reconnect after 3 seconds
    setTimeout(() => {
      window.location.reload();
    }, 3000);
  };
</script>
</body>
</html>
